computational biology solvent-accessible parallel computing advancements in biological research have enabled researchers to obtain large amounts of data especially on dna and protein sequences algorithmic inventions to process biological data are necessary to match their increasing size in this dissertation we present algorithms for solving large-scale problems in sequence comparison accessible surface area computation and string searchcomparison of long biological sequences is of interest due to the availability of long dna sequences such as chromosomes which may be up to several hundred million base pairs long sequence comparison algorithms take time proportional to the product of the input sequences we considered constant and affine gap penalty functions full-sequence and subsequence matching syntenic alignments and also developed space-saving algorithms our algorithms solve all these problems in optimal o [special characters omitted] time and o [special characters omitted] spacesolvent accessible surface area asa is used in determining the energy of protein molecules and protein folding prediction using molecular dynamics simulation computes asa repeatedly each atom in the protein is modeled as a sphere using domain specific knowledge we show that the number of sphere intersections is o  n  where n is the number of atoms in the protein molecule for computing sphere intersections we present a hash-based algorithm that runs in o  n  expected sequential time and a sort-based algorithm that runs in worst-case o  n log n  sequential time optimal parallelization of both the algorithms are also presented our algorithms are a factor of n faster than currently known algorithms we also present a monte carlo algorithm for computing the solvent accessible surface area and provide error bounds as a function of the sample sizepatricia tree suffix tree and suffix array are useful data structures for string search because the search time using them is only a function of the length of the pattern and not the length of the text we present a fast algorithm to construct patricia trees our algorithm can construct a patricia tree in o  n  expected running time and o [special characters omitted] worst-case running time where n is the number of the strings indexed by patricia tree and m is the sum of the length of all the strings finally we present two fast string search algorithms using patricia trees one algorithm uses linear space and searches pattern p with length  p  in o [special characters omitted] time when  p   o [special characters omitted]  where w is the number of bits a processor can process in unit time typically w  32 and o [special characters omitted] time otherwise the other algorithm uses o  n log 2  p  space and searches a patricia tree in o log 2  p  time when  p   o [special characters omitted] 